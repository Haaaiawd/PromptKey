use std::result::Result as StdResult;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use windows::{
    core::*,
    Win32::UI::Accessibility::*,
    Win32::System::Com::*,
    Win32::UI::WindowsAndMessaging::*,
    Win32::Foundation::*,
};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCase {
    pub name: String,
    pub app_name: String,
    pub display_name: String,
    pub test_text: String,
    pub expected_patterns: Vec<String>,
    pub timeout_ms: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    pub test_case: String,
    pub app_name: String,
    pub success: bool,
    pub duration_ms: u64,
    pub patterns_found: Vec<String>,
    pub error_message: Option<String>,
    pub editor_type: String,
    pub class_name: String,
    pub framework_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompatibilityReport {
    pub timestamp: String,
    pub total_tests: usize,
    pub successful_tests: usize,
    pub failed_tests: usize,
    pub success_rate: f64,
    pub test_results: Vec<TestResult>,
    pub summary_by_app: HashMap<String, AppSummary>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppSummary {
    pub app_name: String,
    pub display_name: String,
    pub total_tests: usize,
    pub successful_tests: usize,
    pub success_rate: f64,
    pub supported_patterns: Vec<String>,
    pub recommended_strategy: String,
    pub issues: Vec<String>,
}

pub struct IDECompatibilityTester {
    test_cases: Vec<TestCase>,
}

impl IDECompatibilityTester {
    pub fn new() -> Self {
        let test_cases = Self::create_default_test_cases();
        Self { test_cases }
    }

    fn create_default_test_cases() -> Vec<TestCase> {
        vec![
            TestCase {
                name: "Basic Text Injection".to_string(),
                app_name: "notepad.exe".to_string(),
                display_name: "Notepad".to_string(),
                test_text: "Hello from PromptManager!".to_string(),
                expected_patterns: vec!["ValuePattern".to_string()],
                timeout_ms: 5000,
            },
            TestCase {
                name: "VS Code Editor Test".to_string(),
                app_name: "code.exe".to_string(),
                display_name: "Visual Studio Code".to_string(),
                test_text: "// Test comment from PromptManager\nconsole.log('Hello World');".to_string(),
                expected_patterns: vec!["TextPattern".to_string()],
                timeout_ms: 8000,
            },
            TestCase {
                name: "IntelliJ IDEA Test".to_string(),
                app_name: "idea64.exe".to_string(),
                display_name: "IntelliJ IDEA".to_string(),
                test_text: "/* Test comment */\npublic class TestClass {\n    // Generated by PromptManager\n}".to_string(),
                expected_patterns: vec!["TextPattern".to_string()],
                timeout_ms: 10000,
            },
            TestCase {
                name: "Visual Studio Test".to_string(),
                app_name: "devenv.exe".to_string(),
                display_name: "Visual Studio".to_string(),
                test_text: "// Test code injection\nusing System;\nnamespace TestApp { }".to_string(),
                expected_patterns: vec!["ValuePattern".to_string(), "TextPattern".to_string()],
                timeout_ms: 7000,
            },
            TestCase {
                name: "Notepad++ Test".to_string(),
                app_name: "notepad++.exe".to_string(),
                display_name: "Notepad++".to_string(),
                test_text: "# Test markdown content\n- Generated by PromptManager\n- UIA compatibility test".to_string(),
                expected_patterns: vec!["TextPattern".to_string()],
                timeout_ms: 6000,
            },
        ]
    }

    pub fn run_all_tests(&self) -> StdResult<CompatibilityReport, Box<dyn std::error::Error>> {
        println!("Starting IDE Compatibility Test Suite...");
        let start_time = Instant::now();
        
        let mut test_results = Vec::new();
        let mut successful_tests = 0;
        
        for test_case in &self.test_cases {
            println!("Running test: {} for {}", test_case.name, test_case.display_name);
            
            match self.run_single_test(test_case) {
                Ok(result) => {
                    if result.success {
                        successful_tests += 1;
                        println!("âœ… PASSED: {} ({:.2}ms)", result.test_case, result.duration_ms);
                    } else {
                        println!("âŒ FAILED: {} - {}", result.test_case, 
                               result.error_message.as_deref().unwrap_or("Unknown error"));
                    }
                    test_results.push(result);
                }
                Err(e) => {
                    let failed_result = TestResult {
                        test_case: test_case.name.clone(),
                        app_name: test_case.app_name.clone(),
                        success: false,
                        duration_ms: 0,
                        patterns_found: vec![],
                        error_message: Some(format!("Test execution failed: {}", e)),
                        editor_type: "Unknown".to_string(),
                        class_name: "Unknown".to_string(),
                        framework_id: "Unknown".to_string(),
                    };
                    test_results.push(failed_result);
                    println!("âŒ ERROR: {} - {}", test_case.name, e);
                }
            }
            
            // çŸ­æš‚ç­‰å¾…ï¼Œé¿å…æµ‹è¯•ä¹‹é—´çš„å¹²æ‰°
            std::thread::sleep(Duration::from_millis(1000));
        }
        
        let total_duration = start_time.elapsed();
        let total_tests = test_results.len();
        let success_rate = if total_tests > 0 {
            (successful_tests as f64 / total_tests as f64) * 100.0
        } else {
            0.0
        };
        
        let summary_by_app = self.generate_app_summaries(&test_results);
        
        let report = CompatibilityReport {
            timestamp: chrono::Utc::now().to_rfc3339(),
            total_tests,
            successful_tests,
            failed_tests: total_tests - successful_tests,
            success_rate,
            test_results,
            summary_by_app,
        };
        
        println!("\n=== Test Suite Complete ===");
        println!("Total tests: {}", total_tests);
        println!("Successful: {}", successful_tests);
        println!("Failed: {}", total_tests - successful_tests);
        println!("Success rate: {:.1}%", success_rate);
        println!("Total duration: {:.2}s", total_duration.as_secs_f64());
        
        Ok(report)
    }

    fn run_single_test(&self, test_case: &TestCase) -> StdResult<TestResult, Box<dyn std::error::Error>> {
        let start_time = Instant::now();
        
        // æ£€æŸ¥ç›®æ ‡åº”ç”¨æ˜¯å¦æ­£åœ¨è¿è¡Œ
        if !self.is_app_running(&test_case.app_name) {
            return Ok(TestResult {
                test_case: test_case.name.clone(),
                app_name: test_case.app_name.clone(),
                success: false,
                duration_ms: start_time.elapsed().as_millis() as u64,
                patterns_found: vec![],
                error_message: Some(format!("Application {} is not running", test_case.display_name)),
                editor_type: "Unknown".to_string(),
                class_name: "Unknown".to_string(),
                framework_id: "Unknown".to_string(),
            });
        }

        // åˆå§‹åŒ–COM
        unsafe {
            CoInitializeEx(None, COINIT_APARTMENTTHREADED)?;
        }

        // è·å–UIè‡ªåŠ¨åŒ–å¯¹è±¡
        let automation: IUIAutomation = unsafe {
            CoCreateInstance(&CUIAutomation, None, CLSCTX_INPROC_SERVER)?
        };

        // è·å–ç„¦ç‚¹å…ƒç´ 
        let focused_element = unsafe {
            automation.GetFocusedElement()?
        };

        // æ£€æµ‹ç¼–è¾‘å™¨ä¿¡æ¯
        let class_name = unsafe {
            focused_element.CurrentClassName().unwrap_or_else(|_| "Unknown".into()).to_string()
        };
        
        let framework_id = unsafe {
            focused_element.CurrentFrameworkId().unwrap_or_else(|_| "Unknown".into()).to_string()
        };

        let editor_type = self.detect_editor_type(&class_name, &framework_id, &test_case.app_name);

        // æ£€æµ‹å¯ç”¨çš„UIAæ¨¡å¼
        let mut patterns_found = Vec::new();
        
        // æ£€æŸ¥ValuePattern
        if unsafe { focused_element.GetCurrentPattern(UIA_ValuePatternId).is_ok() } {
            patterns_found.push("ValuePattern".to_string());
        }
        
        // æ£€æŸ¥TextPattern
        if unsafe { focused_element.GetCurrentPattern(UIA_TextPatternId).is_ok() } {
            patterns_found.push("TextPattern".to_string());
        }

        // æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°äº†é¢„æœŸçš„æ¨¡å¼
        let has_expected_patterns = test_case.expected_patterns.iter()
            .any(|expected| patterns_found.contains(expected));

        let duration_ms = start_time.elapsed().as_millis() as u64;
        
        let success = has_expected_patterns && !patterns_found.is_empty();
        let error_message = if !success {
            if patterns_found.is_empty() {
                Some("No UIA patterns found".to_string())
            } else if !has_expected_patterns {
                Some(format!("Expected patterns {:?} not found, got {:?}", 
                           test_case.expected_patterns, patterns_found))
            } else {
                None
            }
        } else {
            None
        };

        Ok(TestResult {
            test_case: test_case.name.clone(),
            app_name: test_case.app_name.clone(),
            success,
            duration_ms,
            patterns_found,
            error_message,
            editor_type,
            class_name,
            framework_id,
        })
    }

    fn is_app_running(&self, app_name: &str) -> bool {
        // ç®€åŒ–çš„åº”ç”¨æ£€æµ‹ - åœ¨å®é™…å®ç°ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„è¿›ç¨‹æ£€æµ‹
        use std::process::Command;
        
        let output = Command::new("tasklist")
            .args(&["/FI", &format!("IMAGENAME eq {}", app_name)])
            .output();
            
        if let Ok(output) = output {
            let stdout = String::from_utf8_lossy(&output.stdout);
            stdout.contains(app_name)
        } else {
            false
        }
    }

    fn detect_editor_type(&self, class_name: &str, framework_id: &str, app_name: &str) -> String {
        match (class_name, framework_id, app_name.to_lowercase().as_str()) {
            ("Scintilla", _, _) => "Scintilla".to_string(),
            (_, "WPF", _) => "WPF".to_string(),
            ("Chrome_WidgetWin_1", _, "code.exe") => "Electron".to_string(),
            (_, _, "idea64.exe") | (_, _, "idea.exe") => "Swing".to_string(),
            _ => "Generic".to_string()
        }
    }

    fn generate_app_summaries(&self, test_results: &[TestResult]) -> HashMap<String, AppSummary> {
        let mut summaries = HashMap::new();
        
        // æŒ‰åº”ç”¨åˆ†ç»„ç»Ÿè®¡
        for result in test_results {
            let entry = summaries.entry(result.app_name.clone()).or_insert_with(|| AppSummary {
                app_name: result.app_name.clone(),
                display_name: self.get_display_name(&result.app_name),
                total_tests: 0,
                successful_tests: 0,
                success_rate: 0.0,
                supported_patterns: Vec::new(),
                recommended_strategy: "unknown".to_string(),
                issues: Vec::new(),
            });

            entry.total_tests += 1;
            if result.success {
                entry.successful_tests += 1;
                
                // æ”¶é›†æ”¯æŒçš„æ¨¡å¼
                for pattern in &result.patterns_found {
                    if !entry.supported_patterns.contains(pattern) {
                        entry.supported_patterns.push(pattern.clone());
                    }
                }
            } else if let Some(error) = &result.error_message {
                if !entry.issues.contains(error) {
                    entry.issues.push(error.clone());
                }
            }
        }
        
        // è®¡ç®—æˆåŠŸç‡å’Œæ¨èç­–ç•¥
        for summary in summaries.values_mut() {
            summary.success_rate = if summary.total_tests > 0 {
                (summary.successful_tests as f64 / summary.total_tests as f64) * 100.0
            } else {
                0.0
            };
            
            // æ ¹æ®æ”¯æŒçš„æ¨¡å¼æ¨èç­–ç•¥
            summary.recommended_strategy = if summary.supported_patterns.contains(&"ValuePattern".to_string()) {
                "uia_value".to_string()
            } else if summary.supported_patterns.contains(&"TextPattern".to_string()) {
                "uia_text".to_string()
            } else {
                "clipboard_fallback".to_string()
            };
        }
        
        summaries
    }

    fn get_display_name(&self, app_name: &str) -> String {
        for test_case in &self.test_cases {
            if test_case.app_name.eq_ignore_ascii_case(app_name) {
                return test_case.display_name.clone();
            }
        }
        app_name.to_string()
    }

    pub fn save_report(&self, report: &CompatibilityReport, output_path: &str) -> StdResult<(), Box<dyn std::error::Error>> {
        let json_content = serde_json::to_string_pretty(report)?;
        std::fs::write(output_path, json_content)?;
        println!("Report saved to: {}", output_path);
        Ok(())
    }

    pub fn print_summary(&self, report: &CompatibilityReport) {
        println!("\n=== IDE Compatibility Report ===");
        println!("Generated: {}", report.timestamp);
        println!("Overall Success Rate: {:.1}%", report.success_rate);
        
        println!("\n--- By Application ---");
        for (app_name, summary) in &report.summary_by_app {
            println!("ğŸ”§ {} ({})", summary.display_name, app_name);
            println!("   Success Rate: {:.1}% ({}/{})", 
                   summary.success_rate, summary.successful_tests, summary.total_tests);
            println!("   Supported Patterns: {:?}", summary.supported_patterns);
            println!("   Recommended Strategy: {}", summary.recommended_strategy);
            if !summary.issues.is_empty() {
                println!("   Issues: {:?}", summary.issues);
            }
            println!();
        }
    }
}

fn main() -> StdResult<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ IDE Compatibility Tester for PromptManager");
    println!("===========================================");
    
    let tester = IDECompatibilityTester::new();
    
    // è¿è¡Œæµ‹è¯•å¥—ä»¶
    let report = tester.run_all_tests()?;
    
    // ä¿å­˜æŠ¥å‘Š
    let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S");
    let report_path = format!("compatibility_report_{}.json", timestamp);
    tester.save_report(&report, &report_path)?;
    
    // æ‰“å°æ‘˜è¦
    tester.print_summary(&report);
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_test_cases() {
        let tester = IDECompatibilityTester::new();
        assert!(!tester.test_cases.is_empty());
        assert!(tester.test_cases.iter().any(|tc| tc.app_name == "notepad.exe"));
    }

    #[test]
    fn test_editor_type_detection() {
        let tester = IDECompatibilityTester::new();
        
        assert_eq!(tester.detect_editor_type("Scintilla", "", "notepad++.exe"), "Scintilla");
        assert_eq!(tester.detect_editor_type("", "WPF", "devenv.exe"), "WPF");
        assert_eq!(tester.detect_editor_type("Chrome_WidgetWin_1", "", "code.exe"), "Electron");
    }
}